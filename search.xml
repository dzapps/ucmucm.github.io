<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Static静态方法与面向对象]]></title>
      <url>%2F2017%2F04%2F20%2FStatic%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[With the this keyword in mind, you can more fully understand what it means to make amethod static. It means that there is no this for that particular method. You cannot call non-static methods from inside static methods [^The one case in which this is possible occurs if you pass a reference to an object into the static method (the static method could also create its own object). Then, via the reference (which is now effectively this), you can call non-static methods and access non-static fields. But typically, if you want to do something like this, you’ll just make an ordinary, non-static method.]: (although the reverse is possible), and you can call a static method for the class itself, without any object. In fact, that’s primarily what a static method is for. It’s as if you’re creating the equivalent of a global method. However,global methods are not permitted in Java, and putting the static method inside a class allowsit access to other static methods and to static fields. Some people argue that static methods are not object-oriented, since they do have the semantics of a global method; with a static method, you don’t send a message to an object, since there’s no this. This is probably a fair argument, and if you find yourself using a lot of static methods, you should probably rethink your strategy. However, statics are pragmatic,and there are times when you genuinely need them, so whether or not they are “proper OOP” should be left to the theoreticians.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java排序算法总结]]></title>
      <url>%2F2017%2F04%2F20%2FJava%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[先定义一些排序算法通用的API 123456789101112131415161718192021222324252627282930313233343536public class Sort&#123; public static void sort(Comparable[] a)&#123; // 新建排序算法对象 Quick quick = new Quick(); quick.sort(a); &#125; protected static boolean less(Comparable v, Comparable w)&#123; return (v.compareTo(w) &lt; 0); &#125; protected static void exc (Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; protected static void show(Comparable[] a)&#123; for (int i =0; i&lt;a.length; i++) System.out.print(a[i] + &quot; &quot;); System.out.println(); &#125; protected static boolean isSorted(Comparable[] a)&#123; for (int i=0; i&lt;a.length; i++) if (less(a[i], a[i+1])) return false; return true; &#125; public static void main(String[] args)&#123; Comparable[] a = &#123;&apos;A&apos;,&apos;R&apos;,&apos;E&apos;,&apos;U&apos;,&apos;K&apos;,&apos;I&apos;,&apos;D&apos;,&apos;D&apos;,&apos;I&apos;,&apos;N&apos;,&apos;G&apos;,&apos;M&apos;,&apos;E&apos;&#125;; sort(a); assert isSorted(a); show(a); &#125;&#125; 插入排序 / Insertion Sort 123456789public class Insertion extends Sort&#123; public static void sort(Comparable[] a)&#123; int N = a.length; for (int i=0; i&lt;N; i++)&#123; for (int j = i; j&gt;0 &amp;&amp; less(a[j],a[j-1]); j--) exc(a,j,j-1); &#125; &#125;&#125; 选择排序 / Selection Sort 123456789101112public class Selection extends Sort&#123; public static void sort(Comparable[] a)&#123; int N = a.length; for (int i=0; i&lt;N; i++)&#123; int min = i; for (int j=i+1; j&lt;N; j++)&#123; if (less(a[j],a[min])) min = j; &#125; exc(a,i,min); &#125; &#125;&#125; 希尔排序 / Shell Sort 1234567891011121314public class Shell extends Sort&#123; public static void sort(Comparable[] a)&#123; int N = a.length(); int h = 1; while (h &lt; N/3) (h = 3*h + 1); while (h &gt;= 1)&#123; for (int i=h; i&lt;N; i++)&#123; for (int j=i; j&gt;=h &amp;&amp; less(a[j],a[j-h]); j-=h) exc(a,j,j-h); &#125; h = h/3; &#125; &#125;&#125; 归并排序 / Merge Sort 1234567891011121314151617181920212223242526272829public class Merge extends Sort&#123; private static Comparable[] aux; public static void sort(Comparable[] a)&#123; aux = new Comparable[a.length]; sort(a,0,a.length-1); &#125; public static void sort(Comparable[] a, int lo, int hi)&#123; if (hi&lt;=lo) return; int mid = lo + (hi-lo)/2; sort(a,lo,mid); sort(a,mid,hi); Merge(a,lo,mid,hi); &#125; public static void Merge(Comparable[] a, int lo, int mid, int hi)&#123; int i = lo; int j = mid + 1; for (int k=lo; k&lt;=hi; k++) aux[k] = a[k]; for (int k=lo; k&lt;=hi; k++)&#123; if (i&gt;mid) a[k] = aux[j++]; else if (j&gt;hi) a[k] = aux[i++]; else if (less(aux[i],aux[j])) a[k] = aux[i++]; else a[k] = a[j++]; &#125; &#125; &#125; 快速排序 / Quick Sort 12345678910111213141516171819202122232425262728public class Quick extends Sort&#123; public static void sort(Comparable[] a)&#123; StdRandom.shuffle(a); sort(a, 0, a.length); &#125; public static void sort(Comparable[] a, int lo, int hi)&#123; if (hi&lt;=lo) return; int j = partition(a,lo,hi); sort(a,lo,j-1); sort(a,j+1,hi); &#125; public static int partition(Comparable[] a, int lo, int hi)&#123; int i = lo; int j = hi+1; Comparable v = a[lo]; while (true)&#123; while (less(a[++i],v)) if (i == hi) break; while (less(v,a[--j])) if (j == lo) break; if (i &gt;= j) break; exc(a,i,j); &#125; // 跟 j 交换位置，因为 i 此时位置在 a[i] &gt; v 处而 a[j] &lt; v exc (a,lo,j); return j; &#125;&#125; 三向切分快速排序 / Quick 3 Ways 1234567891011121314151617public class Quick3Way extends Quick&#123; public static void sort(Comparable[] a, int lo, int hi)&#123; if (lo&gt;=hi) return; int i = lo+1; int gt = hi; int lt = lo; Comparable v = a[lo]; while ( i &lt;= gt )&#123; int cm = v.compareTo(a[i]); if (cm &gt; 0) exc(a,i,gt--); else if (cm &lt; 0) exc(a,lt++,i++); else i++; &#125; sort(a,lo,lt-1); sort(a,gt+1,hi); &#125;&#125; 堆排 / StackSort 数组最大堆： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt; &#123; private Key[] pq; private N = 0; public boolean less(int i, int j)&#123; return pq[i].compareTo(pq[j]) &lt; 0; &#125; public void exc(int i, int j)&#123; Key temp; temp = pq[i]; pq[i] = pq[j]; pq[j] = temp; &#125; public void swin(int k)&#123; while (k&gt;1 &amp;&amp; less(k/2,k))&#123; exc(k/2,k); k /= 2; &#125; &#125; public void sink(int k)&#123; while (2*k &lt;= N)&#123; int j = 2*k; if (j&lt;N &amp;&amp; less(2*k, 2*k+1)) j++; if (!less(k,j)) break; exc(k,j); k = j; &#125; &#125; public MaxPQ (int maxN)&#123; pq = (Key[]) new Comparable[maxN+1]; &#125; public boolean isEmpty()&#123; return N==0; &#125; public void insert(Key v)&#123; pq[++N] = v; swin(N); &#125; public int size()&#123; return N; &#125; public Key delMax()&#123; Key max = pq[1]; exc(N--,1); pq[N+1] = null; sink(1); return max; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738public class StackSort&#123; private Comparable[] a; private int N = a.length; public void StackSort(int max)&#123; a = new Comparable[max]; &#125; public void sort(Comparable[] a)&#123; for (int k = a.length/2; k&gt;=1; k--) sink(k); while (N&gt;1)&#123; exc(N--,1); sink(N); &#125; &#125; public boolean less(int i, int j)&#123; return a[i].compareTo(j) &lt; 0; &#125; piublic void sink(int k)&#123; while (2*k &lt;= a.length)&#123; int j = 2*k; if (less(j,j+1)) j++; if (!less(k,j)) break; exc(k,j); k = j; &#125; &#125; public void exc(int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125;&#125; 就这么多吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Difference between Constructor and void method in Java]]></title>
      <url>%2F2017%2F04%2F17%2FDifference-between-Constructor-and-void-method-in-Java%2F</url>
      <content type="text"><![CDATA[The constructor is an unusual type of method because it has no return value. This is distinctly different from a void return value, in which the method returns nothing but you still have option to make it return something else. Constructors return nothing and you don’t have an option (the new expression does return a reference to the newly created object, but the constructor itself has no return value). 构造器是一种特殊的Method，因为它没有返回值，这个跟void空返回值有很大的区别。因为即使void method本身不会返回什么，你依旧可以让它返回一些东西。构造器不会返回任何东西，你也没有任何选择让它返回什么东西。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java运算符小记]]></title>
      <url>%2F2017%2F04%2F16%2FJava%E8%BF%90%E7%AE%97%E7%AC%A6%E5%B0%8F%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Java运算符记录本，以此记下容易出错的地方。 来自于 Thinking in Java Relational OperatorsThe relational operators == and != also work with all objects. Here is an example: 12345678910111213public class Equivalence&#123; public static void main (String[] args)&#123; Integer n1 = new Integer(47); Integer n2 = new Integer(47); System.out.println(n1 == n2); System.out.println(n1 != n2); &#125;&#125;/* Output:falsetrue*/ The statement System.out.println(n1==n2) will print the result of the boolean comparison within it. While the contents of the objects are the same, the references are not the same. The operators == and != compare object references, so the output is actually “false” and then “true”. What if we want to compare the actual contents of an object for equivalences? We must use the special method equals() that exits for all objects (not primitives, which work fine with == and !=). Example: 123456789public class EqualsMethod&#123; public static void main(String[] args)&#123; Integer n1 = new Integer(47); Integer n2 = new Integer(47); System.out.printly(n1.equals(n2)); &#125;&#125;/* Output: true */ But default equals() does not compare contents. Here is an example: 12345678910111213class Value&#123; int i;&#125;public class EqualsMethod2&#123; public static void main(String[] args)&#123; Value v1 = new Value(); Value v2 = new Value(); v1.i = v2.i = 100; System.out.println(v1.equals(v2)); &#125;&#125;/* Output: false */ The result is false. This is because the default behavior of equals() is to compare references. So unless you override equals() in your new class you won’t get the desired behavior. Most of the Java library classes implement equals() so that it compares the contents of objects instead of their references. Bitwise OperatorsThe bitwise operators allow you to manipulate individual bits in an integral primitive data type. Bitwise operators perform Boolean algebra on the corresponding bits in the two arguments to produce the result. The bitwise operators come from C’s low-level orientation, where you often manipulate hardware directly and must set the bits in hardware registers. Java was originally designed to be embedded in TV set-top boxes, so this low-level orientation still made sense. The bitwise AND operator (&amp;) produces a one in the output bit if both input bits are one; otherwise, it produces a zero. 12345678910111213// Exampleclass Bitwise&#123; public static void main(String[] args)&#123; int a = 129; int b = 128; System.out.println(a&amp;b); &#125;&#125;/* Output: 128;Integer.toBinaryString(a) is 10000001;Integer.toBinaryString(b) is 10000000;Integer.toBinaryString(a&amp;b) is 10000000; */ The bitwise OR operator (|) produces a one in the output bit if either input is a one and produces a zero only if both input bits are zero. 12345678910111213// Exampleclass Bitwise&#123; public static void main(String[] args)&#123; int a = 129; int b = 128; System.out.println(a|b); &#125;&#125;/* Output: 129;Integer.toBinaryString(a) is 10000001;Integer.toBinaryString(b) is 10000000;Integer.toBinaryString(a|b) is 10000001; */ The bitwise EXCLUSIVE OR, or XOR (^) , produces a one in the output bit if one or the other input bit is a one, but not both, which means if the bits are same, producing 0, if the bits are different, producing 1. 12345678910111213// Exampleclass Bitwise&#123; public static void main(String[] args)&#123; int a = 15; int b = 2; System.out.println(a^b); &#125;&#125;/* Output: 13;Integer.toBinaryString(a) is 1111;Integer.toBinaryString(b) is 0010;Integer.toBinaryString(a^b) is 1101; */ The bitwise NOT, also called the ones complement operator, (~), is a unary operator; it takes only one argument. (All other bitwise operators are binary operators.) Bitwise NOT produces the opposite of the input bit - a one if the input bit is zero, a zero if the input bit is one. 12345678910// Exampleclass Bitwise&#123; public static void main(String[] args)&#123; int a = 2; System.out.println(~a); &#125;&#125;/* Output: -3;Integer.toBinaryString(a) is 10;Integer.toBinaryString(~a) is 1111 1111 1111 1111 1111 1111 1111 1101; */]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[A Review of Sugar Factory]]></title>
      <url>%2F2017%2F04%2F15%2FA-Review-of-Sugar-Factory%2F</url>
      <content type="text"><![CDATA[无比气愤，好端端一顿饭吃成这样。 故写此评论，发在了Yelp上，同时在此博客上记录下来。 It was a really HORRIBLE EXPERIENCE today. I would never be here again and never recommend my friends this restaurant ever. The service here is the WORST, WORST, WORST I have ever been through. When my girl friend and I sat down, the waiter (Just call her “Ellen”) came to us and said what drinks would we want. After we ordered the drinks, she just walked away without saying anything. We haven’t even ordered food. So we told her that we wanted to order food. After then, we wanted some alcohol, so we raised our hand and wanted to order more. She saw it, and said impatiently: “Do not do that again.” WHAT ARE YOU F**KING KIDDING ME??? We were customers and we wanted to order some drinks, and this was what a waiter said to us?? Okay, then LET’S SEE WHAT THEIR MANAGERS DID. I went and told their woman manager that what the waiter said to us. She said she would talk to us later. 10 minutes later, NOTHING HAPPENED. I went and asked her again that we needed an explanation and sorry. She said okay she would deal with this. Of course, NOTHING HAPPENED EITHER. Then I went for her third times, finally another one came and asked us what happened, then she seemed to talk to “Ellen”. As expected, NOTHING HAPPENED. Until we were going to leave, a man who seems to be another manger, called C. K., said a lot high-sounding words without any sincerity. THOSE WORDS WERE ALL BULLSHIT. We DIDN’T HEAR SORRY from “Ellen” and DIDN’T FEEL ANY APOLOGIES from their managers. They just wanted us leave. They didn’t even care about this. They have too many customers, so they can make too much money from customers. They don’t even care what happened to the customers. She was rude to us, so why should we show respect to her? The managers didn’t care about our customers, so WHY SHOULD WE CUSTOMERS BE DESPISED EVEN WE GIVING MONEY TO THEM?? I should read the reviews from the Yelp before I went there. Someone also mentioned that how rude the waiters were. More customers went there, the feelings and reviews of customers would become much cheaper. Just look at their attitudes to customers. They might be proud of this attitude because they beat the customers again. 真他妈气，一天心情都不好。]]></content>
    </entry>

    
  
  
</search>
